/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  test                                   */
/*      FILE         :  test.c                                 */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  SH-2                                   */
/*      CPU TYPE     :  SH7125                                 */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/

#include "typedefine.h"
#include "iodefine.h"
#include "serial.h"
#include "init.h"
#include "util.h"
#include "LED.h"
#include "CMT.h"
#include "sensor.h"
#include "MTU.h"
#include "motor.h"
#include "map.h"
#include "math.h"

#define round(A)((int)(A + 0.5))

int route_index;

extern SPC spec;
extern SEN r_sen, cr_sen, l_sen, cl_sen;
extern MOT r_motor, l_motor;
extern SW Switch;
extern CMT_01 tim;
extern MAP map;

enum mode {
	astar = 0, search = 1, show_map = 2, test = 3, run = 4
};


void sen_calibration() {

	UX_effect(alart);

	cr_sen.non_threshold = cr_sen.sen;
	cl_sen.non_threshold = cl_sen.sen;
	r_sen.ref_wall = r_sen.sen;
	l_sen.ref_wall = l_sen.sen;
	while (PB.DR.BIT.B5 != 0) {
		//remove walls
		drv_Status_LED(Green, on);
	}

	UX_effect(alart);
	myprintf("ref_wall : %d | %d\n", l_sen.ref_wall, r_sen.ref_wall);

	cr_sen.non_threshold += cr_sen.sen;
	cl_sen.non_threshold += cl_sen.sen;
	r_sen.non_threshold = r_sen.sen;
	l_sen.non_threshold = l_sen.sen;

	cr_sen.non_threshold /= 2;
	cl_sen.non_threshold /= 2;

	while (PB.DR.BIT.B5 != 0) {
		drv_Status_LED(Yerrow, on);
	}

	myprintf("non_wall : %d | %d | %d | %d\n", l_sen.non_threshold,
			cl_sen.non_threshold, cr_sen.non_threshold, r_sen.non_threshold);
	UX_effect(alart);
	drv_Status_LED(Rst_status_LED, off);
}

////void Rotate_detect(void) {
////	int now = PE.DRL.BIT.B14;
////	now = now << 1;
////	now += PE.DRL.BIT.B15;
////
////	if (now == 3) {
////		now = 2;
////	} else if (now == 2) {
////		now = 3;
////	}
////
////	if (old == 0 && now == 3) {
////		rot -= 1;
////		UX_effect(click);
////	} else if (old == 3 && now == 0) {
////		rot += 1;
////		UX_effect(click);
////	} else if (now > old) {
////		rot += 1;
////		UX_effect(click);
////	} else if (now < old) {
////		rot -= 1;
////		UX_effect(click);
////	} else {
////		rot += 0;
////	}
////	old = now;
////
////}
////
////void select_Mode() {
////	rot_sw = (char) (rot % 5);
////	Rotate_detect();
////	sta_LED_drv(Red, (rot_sw + 1) & 1);
////	sta_LED_drv(Yerrow, ((rot_sw + 1) & 2) >> 1);
////	sta_LED_drv(Green, ((rot_sw + 1) & 4) >> 2);
////}
//
////void detect_Direction() {
////	if (direction == 0) {
////		pos_y += 1;
////		/*
////		 sta_LED_drv(Red, off);
////		 sta_LED_drv(Yerrow, off);
////		 sta_LED_drv(Green, on);
////		 */
////	} else if (direction == 1) {
////		pos_x += 1;
////		/*
////		 sta_LED_drv(Red, on);
////		 sta_LED_drv(Yerrow, off);
////		 sta_LED_drv(Green, off);
////		 */
////	} else if (direction == 3) {
////		pos_x -= 1;
////		/*
////		 sta_LED_drv(Red, off);
////		 sta_LED_drv(Yerrow, on);
////		 sta_LED_drv(Green, off);
////		 */
////	} else if (direction == 2) {
////		pos_y -= 1;
////		/*
////		 sta_LED_drv(Red, off);
////		 sta_LED_drv(Yerrow, off);
////		 sta_LED_drv(Green, off);
////		 */
////	}
////	drv_Status_LED(Red, pos_y & 1);
////	drv_Status_LED(Yerrow, (pos_x & 1) >> 0);
////	drv_Status_LED(Green, (pos_x & 2) >> 1);
////
////}
//
////void move_Left() {
////	kp_r -= 0.1;
////	kp_l -= 0.1;
////	mot_app(half_block, 330, 2000, straight, on);
////	wait_ms(100);
////	switch_Motor(off);
////	wait_ms(450);
////	switch_Motor(on);
////	wait_ms(100);
////	mot_app(l_distance, 310, 2000, left, on);
////	wait_ms(100);
////	switch_Motor(off);
////	wait_ms(450);
////	switch_Motor(on);
////	wait_ms(100);
////	mot_app2(half_block, 330, 2000, straight, on);
////	kp_r += 0.1;
////	kp_l += 0.1;
////}
////
////void move_Right() {
////	kp_r -= 0.1;
////	kp_l -= 0.1;
////	mot_app(half_block, 330, 2000, straight, on);
////	wait_ms(100);
////	switch_Motor(off);
////	wait_ms(450);
////	switch_Motor(on);
////	wait_ms(100);
////	mot_app(r_distance, 310, 2000, right, on);
////	wait_ms(100);
////	switch_Motor(off);
////	wait_ms(450);
////	switch_Motor(on);
////	wait_ms(100);
////	mot_app2(half_block, 330, 1800, straight, on);
////	kp_r += 0.1;
////	kp_l += 0.1;
////
////}
////
////void move_Forward() {
////	kp_r += 0.1;
////	kp_l += 0.1;
////	mot_app2(full_block, 480, 2000, straight, on);
////	kp_r -= 0.1;
////	kp_l -= 0.1;
////}
////
////void move_Backward() {
////	mot_app(half_block, 330, 2000, straight, on);
////	wait_ms(1000);
////	mot_app(r_distance, 310, 2000, right, on);
////	wait_ms(1000);
////	mot_app(half_block, 270, 2000, back, on);
////	switch_Motor(off);
////	wait_ms(1000);
////	switch_Motor(on);
////	mot_app(18, 280, 2000, straight, on);
////	wait_ms(1000);
////	mot_app(r_distance, 310, 2000, right, on);
////	wait_ms(1000);
////	mot_app(half_block, 270, 2000, back, on);
////	switch_Motor(off);
////	wait_ms(1000);
////	switch_Motor(on);
////	mot_app2(15 + half_block, 330, 2000, straight, on);
////
////}
////
////void move_Backward_2() {
////	mot_app(half_block, 330, 2000, straight, on);
////	wait_ms(100);
////	switch_Motor(off);
////	wait_ms(450);
////	switch_Motor(on);
////	wait_ms(100);
////	mot_app(r_distance, 310, 2000, right, on);
////	mot_app(r_distance, 310, 2000, right, on);
////	wait_ms(100);
////	switch_Motor(off);
////	wait_ms(450);
////	switch_Motor(on);
////	wait_ms(100);
////	mot_app2(half_block, 330, 2000, straight, on);
////
////}
//
////void update_Wall_map() {
////	/*
////	 * wall : W-S-E-N
////	 * 		 MSB   LSB
////	 *
////	 * map_x : vertical walls to x-axis
////	 * map_y : vertical walls to y-axis
////	 * */
////
////	wall = 0;
////	if (r_sen.sen > r_sen.non_threshold) {
////		wall |= 1 << ((1 + direction) % 4);
////	}
////	if (l_sen.sen > l_sen.non_threshold) {
////		wall |= 1 << ((3 + direction) % 4);
////	}
////	if (cl_sen.sen > cl_sen.non_threshold) {
////		wall |= 1 << ((0 + direction) % 4);
////	}
////
////	if (pos_x < map_size - 1) {
////		wall_map_x[pos_x] |= ((wall & 2) >> 1) << pos_y;
////		searched_map_x[pos_x] &= ~(1 << pos_y);
////	}
////	if (pos_x - 1 >= 0) {
////		wall_map_x[pos_x - 1] |= ((wall & 8) >> 3) << pos_y;
////		searched_map_x[pos_x - 1] &= ~(1 << pos_y);
////	}
////
////	if (pos_y < map_size - 1) {
////		wall_map_y[pos_y] |= ((wall & 1) >> 0) << pos_x;
////		searched_map_y[pos_y] &= ~(1 << pos_x);
////	}
////	if (pos_y - 1 >= 0) {
////		wall_map_y[pos_y - 1] |= ((wall & 4) >> 2) << pos_x;
////		searched_map_y[pos_y - 1] &= ~(1 << pos_x);
////	}
////}
//
////void print_Wall_map_x(int row) {
////	int i, mask = 1;
////	mask <<= row;
////
////	for (i = 0; i < map_size - 1; i++) {
////		myprintf("  ");
////		if (wall_map_x[i] & mask) {
////			myprintf("|");
////		} else {
////			myprintf(" ");
////		}
////	}
////
////}
////
////void print_Wall_map_y(int row) {
////	int i, mask;
////	for (i = 0; i < map_size - 1; i++) {
////		mask = 1 << i;
////		if (wall_map_y[row] & mask) {
////			myprintf("--");
////		} else {
////			myprintf("  ");
////		}
////		myprintf("+");
////	}
////	mask <<= 1;
////	if (wall_map_y[row] & mask) {
////		myprintf("--");
////	} else {
////		myprintf("  ");
////	}
////
////}
//
////void print_Wall_map() {
////	int i;
////	myprintf("\n");
////	for (i = 0; i < map_size; i++) {
////		myprintf("+--");
////	}
////	myprintf("+\n|");
////
////	print_Wall_map_x(map_size - 1);
////	myprintf("  |\n+");
////	for (i = 1; i < map_size; i++) {
////		print_Wall_map_y(map_size - 1 - i);
////		myprintf("+\n|");
////		print_Wall_map_x(map_size - 1 - i);
////		myprintf("  |\n+");
////	}
////
////	for (i = 0; i < map_size; i++) {
////		myprintf("--+");
////	}
////	myprintf("\n\n");
////}
//
////char read_Wall_map(char x, char y) {
////
////	/*
////	 *  wall : W-S-E-N
////	 * 		 MSB   LSB
////	 */
////
////	char wall = 0;
////
////	//myprintf("\n\n");
////
////	if (x < map_size - 1) {
////		wall |= ((wall_map_x[x] & (1 << y)) >> y) << 1;
////		//myprintf("%d\n", ((mixed_map_x[x] & (1 << y)) >> y) << 1);
////	}
////	if (x - 1 >= 0) {
////		wall |= ((wall_map_x[x - 1] & (1 << y)) >> y) << 3;
////		//myprintf("%d\n", ((mixed_map_x[x - 1] & (1 << y)) >> y) << 3);
////	}
////
////	if (y < map_size - 1) {
////		wall |= (wall_map_y[y] & (1 << x)) >> x;
////		//myprintf("%d\n", (mixed_map_y[y] & (1 << x)) >> x);
////	}
////	if (y - 1 >= 0) {
////		wall |= ((wall_map_y[y - 1] & (1 << x)) >> x) << 2;
////		//myprintf("%d\n", ((mixed_map_y[y - 1] & (1 << x)) >> x) << 2);
////	}
////	return wall;
////
////}
//
///*void print_Searched_map_x(int row) {
//	int i, mask = 1;
//	mask <<= row;
//
//	for (i = 0; i < map_size - 1; i++) {
//		myprintf("  ");
//		if (searched_map_x[i] & mask) {
//			myprintf("|");
//		} else {
//			myprintf(" ");
//		}
//	}
//
//}
//
//void print_Searched_map_y(int row) {
//	int i, mask;
//	for (i = 0; i < map_size - 1; i++) {
//		mask = 1 << i;
//		if (searched_map_y[row] & mask) {
//			myprintf("--");
//		} else {
//			myprintf("  ");
//		}
//		myprintf("+");
//	}
//	mask <<= 1;
//	if (searched_map_y[row] & mask) {
//		myprintf("--");
//	} else {
//		myprintf("  ");
//	}
//
//}
//
//void print_Searched_map() {
//	int i;
//	myprintf("\n");
//	for (i = 0; i < map_size; i++) {
//		myprintf("+--");
//	}
//	myprintf("+\n|");
//
//	print_Searched_map_x(map_size - 1);
//	myprintf("  |\n+");
//	for (i = 1; i < map_size; i++) {
//		print_Searched_map_y(map_size - 1 - i);
//		myprintf("+\n|");
//		print_Searched_map_x(map_size - 1 - i);
//		myprintf("  |\n+");
//	}
//
//	for (i = 0; i < map_size; i++) {
//		myprintf("--+");
//	}
//	myprintf("\n\n");
//}*/
//
///*void initwall_map() {
//	int i;
//	for (i = 0; i < map_size - 1; i++) {
//		wall_map_x[i] = 0;
//		wall_map_y[i] = 0;
//		searched_map_x[i] = 0xffffffff;
//		searched_map_y[i] = 0xffffffff;
//
//	}
//}*/
//
///*void mix_map() {
//	int i;
//	for (i = 0; i < map_size - 1; i++) {
//		mixed_map_x[i] = wall_map_x[i] | searched_map_x[i];
//		mixed_map_y[i] = wall_map_y[i] | searched_map_y[i];
//	}
//}*/
//
///*void print_Mixed_map_x(int row) {
//	int i, mask = 1;
//	mask <<= row;
//
//	for (i = 0; i < map_size - 1; i++) {
//		myprintf("  ");
//		if (mixed_map_x[i] & mask) {
//			myprintf("|");
//		} else {
//			myprintf(" ");
//		}
//	}
//
//}
//
//void print_Mixed_map_y(int row) {
//	int i, mask;
//	for (i = 0; i < map_size - 1; i++) {
//		mask = 1 << i;
//		if (mixed_map_y[row] & mask) {
//			myprintf("--");
//		} else {
//			myprintf("  ");
//		}
//		myprintf("+");
//	}
//	mask <<= 1;
//	if (mixed_map_y[row] & mask) {
//		myprintf("--");
//	} else {
//		myprintf("  ");
//	}
//
//}
//
//void print_Mixed_map() {
//	int i;
//	myprintf("\n");
//	for (i = 0; i < map_size; i++) {
//		myprintf("+--");
//	}
//	myprintf("+\n|");
//
//	print_Mixed_map_x(map_size - 1);
//	myprintf("  |\n+");
//	for (i = 1; i < map_size; i++) {
//		print_Mixed_map_y(map_size - 1 - i);
//		myprintf("+\n|");
//		print_Mixed_map_x(map_size - 1 - i);
//		myprintf("  |\n+");
//	}
//
//	for (i = 0; i < map_size; i++) {
//		myprintf("--+");
//	}
//	myprintf("\n\n");
//}*/
//
///*char read_Mixed_map(char x, char y) {
//
//
//	 *  wall : W-S-E-N
//	 * 		 MSB   LSB
//
//
//	char wall = 0;
//
//	myprintf("\n\n");
//
//	if (x < map_size - 1) {
//		wall |= ((mixed_map_x[x] & (1 << y)) >> y) << 1;
//		//myprintf("%d\n", ((mixed_map_x[x] & (1 << y)) >> y) << 1);
//	}
//	if (x - 1 >= 0) {
//		wall |= ((mixed_map_x[x - 1] & (1 << y)) >> y) << 3;
//		//myprintf("%d\n", ((mixed_map_x[x - 1] & (1 << y)) >> y) << 3);
//	}
//
//	if (y < map_size - 1) {
//		wall |= (mixed_map_y[y] & (1 << x)) >> x;
//		//myprintf("%d\n", (mixed_map_y[y] & (1 << x)) >> x);
//	}
//	if (y - 1 >= 0) {
//		wall |= ((mixed_map_y[y - 1] & (1 << x)) >> x) << 2;
//		//myprintf("%d\n", ((mixed_map_y[y - 1] & (1 << x)) >> x) << 2);
//	}
//	return wall;
//
//}*/
//
///*void update_A_dist_map() {
//	unsigned char buff_x = 0, buff_y = 0, wall, dist = 0;
//	int i, j, k;
//
//	while (a_star_dist_map[pos_x][pos_y] == 255) {
//		for (i = 0; i < map_size; i++) {
//			for (j = 0; j < map_size; j++) {
//				if (a_star_dist_map[i][j] == dist) {
//					buff_x = i;
//					buff_y = j;
//					wall = read_Wall_map(buff_x, buff_y);
//
//					if ((wall & 2) != 2) {
//						if (buff_x != (map_size - 1)) {
//							if (a_star_dist_map[buff_x + 1][buff_y] == 255) {
//								a_star_dist_map[buff_x + 1][buff_y] = dist + 1;
//							}
//						}
//					}
//					if ((wall & 8) != 8) {
//						if (buff_x != 0) {
//							if (a_star_dist_map[buff_x - 1][buff_y] == 255) {
//								a_star_dist_map[buff_x - 1][buff_y] = dist + 1;
//							}
//						}
//					}
//
//					if ((wall & 1) != 1) {
//						if (buff_y != (map_size - 1)) {
//							if (a_star_dist_map[buff_x][buff_y + 1] == 255) {
//								a_star_dist_map[buff_x][buff_y + 1] = dist + 1;
//							}
//						}
//					}
//
//					if ((wall & 4) != 4) {
//						if (buff_y != 0) {
//							if (a_star_dist_map[buff_x][buff_y - 1] == 255) {
//								a_star_dist_map[buff_x][buff_y - 1] = dist + 1;
//							}
//						}
//					}
//				}
//			}
//		}
//		dist += 1;
//	}
//
//}*/
//
///*char generate_A_path() {
//
//	 * =================
//	 * about path[]
//	 * 0:forward
//	 * 1:right
//	 * 2:backward
//	 * 3:left
//	 * 4:goal
//	 * =================
//	 * wall : W-S-E-N
//	 * 		 MSB   LSB
//	 * =================
//	 * dir : 0 North
//	 * 		 1 East
//	 * 		 2 South
//	 * 		 3 West
//	 * =================
//	 *
//	char x = pos_x, y = pos_y, dir = direction, rel_dir, wall, dist, min_dist,
//			pri_flag;
//	int i = 0;
//
//	wall = read_Wall_map(x, y);
//	dist = a_star_dist_map[x][y];
//	pri_flag = 4;
//
//	if ((wall & 4) == 0) {
//		if (y - 1 >= 0) {
//			if (a_star_dist_map[x][y - 1] <= dist) {
//				dist = a_star_dist_map[x][y - 1];
//				min_dist = 2;
//				if (min_dist == dir) {
//					pri_flag = dir;
//				}
//			}
//		}
//	}
//
//	if ((wall & 2) == 0) {
//		if (x + 1 < map_size) {
//			if (a_star_dist_map[x + 1][y] <= dist) {
//				dist = a_star_dist_map[x + 1][y];
//				min_dist = 1;
//				if (min_dist == dir) {
//					pri_flag = dir;
//				}
//			}
//		}
//	}
//
//	if ((wall & 8) == 0) {
//		if (x - 1 >= 0) {
//			if (a_star_dist_map[x - 1][y] <= dist) {
//				dist = a_star_dist_map[x - 1][y];
//				min_dist = 3;
//				if (min_dist == dir) {
//					pri_flag = dir;
//				}
//			}
//		}
//	}
//
//	if ((wall & 1) == 0) {
//		if (y + 1 < map_size) {
//			if (a_star_dist_map[x][y + 1] <= dist) {
//				dist = a_star_dist_map[x][y + 1];
//				min_dist = 0;
//				if (min_dist == dir) {
//					pri_flag = dir;
//				}
//			}
//		}
//	}
//
//	if (pri_flag != 4) {
//		min_dist = pri_flag;
//	}
//
//	rel_dir = min_dist - dir;
//	if (rel_dir < 0) {
//		rel_dir += 4;
//	}
//	return rel_dir;
//}*/
//
///*void initdist_map() {
//	int i, j;
//
//	for (i = 0; i < map_size; i++) {
//		for (j = 0; j < map_size; j++) {
//			dist_map[i][j] = 255;
//			a_star_dist_map[i][j] = 255;
//		}
//	}
//	dist_map[goal_x][goal_y] = 0;
//	a_star_dist_map[goal_x][goal_y] = 0;
//}*/
//
///*void init_Dist_map() {
//	int i, j;
//
//	for (i = 0; i < map_size; i++) {
//		for (j = 0; j < map_size; j++) {
//			dist_map[i][j] = 255;
//		}
//	}
//	dist_map[goal_x][goal_y] = 0;
//
//}*/
//
///*void init_A_dist_map() {
//	int i, j;
//
//	for (i = 0; i < map_size; i++) {
//		for (j = 0; j < map_size; j++) {
//			a_star_dist_map[i][j] = 255;
//		}
//	}
//	a_star_dist_map[goal_x][goal_y] = 0;
//}*/
//
///*void print_Dist_map() {
//	int i, j;
//
//	myprintf("\n");
//	for (i = 0; i < map_size; i++) {
//		for (j = 0; j < map_size; j++) {
//			myprintf("%3d ", dist_map[j][map_size - 1 - i]);
//		}
//		myprintf("\n");
//	}
//}*/
//
///*
//void update_Dist_map() {
//	unsigned char buff_x = 0, buff_y = 0, wall, dist = 0;
//	int i, j, k;
//	mix_map();
//	print_Mixed_map();
//	while (dist_map[0][0] == 255) {
//		for (i = 0; i < map_size; i++) {
//			for (j = 0; j < map_size; j++) {
//				if (dist_map[i][j] == dist) {
//					buff_x = i;
//					buff_y = j;
//					wall = read_Mixed_map(buff_x, buff_y);
//
//					if ((wall & 2) != 2) {
//						if (buff_x != (map_size - 1)) {
//							if (dist_map[buff_x + 1][buff_y] == 255) {
//								dist_map[buff_x + 1][buff_y] = dist + 1;
//							}
//						}
//					}
//					if ((wall & 8) != 8) {
//						if (buff_x != 0) {
//							if (dist_map[buff_x - 1][buff_y] == 255) {
//								dist_map[buff_x - 1][buff_y] = dist + 1;
//							}
//						}
//					}
//
//					if ((wall & 1) != 1) {
//						if (buff_y != (map_size - 1)) {
//							if (dist_map[buff_x][buff_y + 1] == 255) {
//								dist_map[buff_x][buff_y + 1] = dist + 1;
//							}
//						}
//					}
//
//					if ((wall & 4) != 4) {
//						if (buff_y != 0) {
//							if (dist_map[buff_x][buff_y - 1] == 255) {
//								dist_map[buff_x][buff_y - 1] = dist + 1;
//							}
//						}
//					}
//				}
//			}
//		}
//		print_Dist_map();
//		dist += 1;
//	}
//}
//*/
//
///*
//char read_dist_map(char x, char y) {
//	return dist_map[x][y];
//}
//*/
//
///*
//void generate_Path() {
//
//	 * =================
//	 * about path[]
//	 * 0:forward
//	 * 1:right
//	 * 2:backward
//	 * 3:left
//	 * 4:goal
//	 * =================
//	 * wall : W-S-E-N
//	 * 		 MSB   LSB
//	 * =================
//	 * dir : 0 North
//	 * 		 1 East
//	 * 		 2 South
//	 * 		 3 West
//	 * =================
//	 *
//	char x = 0, y = 0, dir = direction, rel_dir = direction, wall, dist,
//			min_dist, pri_flag;
//	int i = 0;
//
//	myprintf("=======\n");
//
//	while (dist_map[x][y] != 0) {
//		wall = read_Mixed_map(x, y);
//		dist = dist_map[x][y];
//		pri_flag = 4;
//
//		if ((wall & 1) == 0) {
//			if (y + 1 < map_size) {
//				if (dist_map[x][y + 1] <= dist) {
//					dist = dist_map[x][y + 1];
//					min_dist = 0;
//					if (dir == min_dist) {
//						pri_flag = dir;
//					}
//				}
//
//			}
//		}
//		if ((wall & 2) == 0) {
//			if (x + 1 < map_size) {
//				if (dist_map[x + 1][y] <= dist) {
//					dist = dist_map[x + 1][y];
//					min_dist = 1;
//					if (dir == min_dist) {
//						pri_flag = dir;
//					}
//				}
//
//			}
//		}
//		if ((wall & 4) == 0) {
//			if (y - 1 >= 0) {
//				if (dist_map[x][y - 1] <= dist) {
//					dist = dist_map[x][y - 1];
//					min_dist = 2;
//					if (dir == min_dist) {
//						pri_flag = dir;
//					}
//				}
//
//			}
//		}
//		if ((wall & 8) == 0) {
//			if (x - 1 >= 0) {
//				if (dist_map[x - 1][y] <= dist) {
//					dist = dist_map[x - 1][y];
//					min_dist = 3;
//					if (dir == min_dist) {
//						pri_flag = dir;
//					}
//				}
//
//			}
//		}
//
//		if (pri_flag != 4) {
//			min_dist = pri_flag;
//			myprintf("====\n");
//		}
//
//		if (min_dist == 0) {
//			y += 1;
//		} else if (min_dist == 1) {
//			x += 1;
//		} else if (min_dist == 2) {
//			y -= 1;
//		} else if (min_dist == 3) {
//			x -= 1;
//		}
//
//		rel_dir = min_dist - dir;
//		if (rel_dir < 0) {
//			rel_dir += 4;
//		}
//
//		dir = min_dist;
//		myprintf("(%d,%d)\n", x, y);
//		myprintf("%d\n", rel_dir);
//		path[i] = rel_dir;
//
//		i++;
//	}
//}*/
//
///*void init_Path() {
//	int i;
//	for (i = 0; i < map_size * map_size; i++) {
//		path[i] = 4;
//	}
//}*/

int main(void) {
	float v_r = 0;
	float v_l = 0;
	init_sci1();
	init_ALL();

	switch_Motor(off);

	while (1) {
		while (spec.batt < 11.3) {
			get_Battery_Voltage();
			myprintf("Low_battery\n");
			UX_effect(error);
		}

		drv_Status_LED(Red, off);

		while (PB.DR.BIT.B5 != 0) {
			//batt = get_Battery_Voltage();
			get_Battery_Voltage();
			select_Mode();
			myprintf("batt : %f\n", spec.batt);
			myprintf("sen : %d | %d | %d | %d\n", l_sen.sen, cl_sen.sen,
					cr_sen.sen, r_sen.sen);
			myprintf("mode : %d\n", Switch.rot_sw);
			wait_ms(100);
		}
		wait_ms(100);
		drv_Status_LED(Rst_status_LED, off);
		switch (Switch.rot_sw) {

		case astar:
			spec.sta_LED_flag = 0;
			map.pos_x = 0;
			map.pos_y = 1;
			map.direction = 0;
			spec.run_interruption = 0;
			UX_effect(alart);

			switch_Motor(on);
			mot_app2(spec.half_block, 330, 1500, straight, on);

			while (spec.run_interruption != 1) {
				update_Wall_map();
				update_A_dist_map();
				map.tmp_path = generate_A_path();
				init_A_dist_map();

				if (map.tmp_path == 1) {
					map.direction += 1;
					move_Right();
				} else if (map.tmp_path == 3) {
					map.direction += 3;
					move_Left();
				} else if (map.tmp_path == 0) {
					map.direction += 0;
					move_Forward(450);
				} else if (map.tmp_path == 2) {
					map.direction += 2;
					if (map.wall == 7 || map.wall == 11 || map.wall == 13 || map.wall == 14) {
						move_Backward();
					} else {
						move_Backward_2();
					}
				}
				map.direction %= 4;

				detect_Direction();
				if (map.pos_x == map.goal_x & map.pos_y == map.goal_y) {
					spec.run_interruption = 1;
				}
			}
			update_Wall_map();
			mot_app(spec.half_block, 310, 1500, straight, on);
			wait_ms(300);
			switch_Motor(off);
			spec.sta_LED_flag = 0;
			map.pos_x = 0;
			map.pos_y = 0;
			init_Path();
			init_Dist_map();
			update_Dist_map();
			generate_Path();
			break;

		case run:
			spec.sta_LED_flag = 0;
			map.pos_x = 0;
			map.pos_y = 1;
			map.direction = 0;
			spec.run_interruption = 0;
			UX_effect(alart);
			route_index = 1;

			switch_Motor(on);
			mot_app2(spec.half_block, 330, 1500, straight, on);

			while (map.path[route_index] != 4) {
				update_Wall_map();

				if (map.path[route_index] == 1) {
					map.direction += 1;
					move_Right();

				} else if (map.path[route_index] == 3) {
					map.direction += 3;
					move_Left();
				} else if (map.path[route_index] == 0) {
					map.direction += 0;
					move_Forward(500);
				} else {
					map.direction += 2;
					move_Backward_2();
				}
				map.direction %= 4;

				detect_Direction();
				route_index += 1;
			}
			update_Wall_map();
			mot_app(spec.half_block, 310, 1500, straight, on);
			wait_ms(300);
			spec.sta_LED_flag = 0;
			map.pos_x = map.goal_x;
			map.pos_y = map.goal_y;
			switch_Motor(off);
			break;

		case search:
			spec.sta_LED_flag = 0;
			map.pos_x = 0;
			map.pos_y = 1;
			map.direction = 0;
			spec.run_interruption = 0;
			UX_effect(alart);

			switch_Motor(on);
			mot_app2(spec.half_block, 330, 1500, straight, on);

			while (spec.run_interruption != 1) {
				update_Wall_map();

				if (l_sen.sen <= l_sen.non_threshold) {
					map.direction += 3;
					move_Left();
				} else if (cl_sen.sen <= cl_sen.non_threshold) {
					map.direction += 0;
					move_Forward(480);
				} else if (r_sen.sen <= r_sen.non_threshold) {
					map.direction += 1;
					move_Right();

				} else {
					map.direction += 2;
					move_Backward();
				}
				map.direction %= 4;

				detect_Direction();
				if (map.pos_x == map.goal_x & map.pos_y == map.goal_y) {
					spec.run_interruption = 1;
				}
			}
			update_Wall_map();
			mot_app(spec.half_block, 310, 1500, straight, on);
			wait_ms(300);
			switch_Motor(off);
			spec.sta_LED_flag = 0;
			map.pos_x = 0;
			map.pos_y = 0;
			init_Dist_map();
			update_Dist_map();
			generate_Path();
			break;

		case show_map:

			spec.sta_LED_flag = 0;
			map.direction = 0;
			UX_effect(alart);
			print_Wall_map();
			print_Searched_map();
			init_Path();
			update_Dist_map();
			generate_Path();
			break;

		case test:

			spec.sta_LED_flag = 1;

			UX_effect(alart);
			switch_Motor(on);
			wait_ms(100);
			mot_app2(spec.half_block, 330, 2000, straight, on);
			mot_app(spec.half_block, 330, 2000, straight, on);
			wait_ms(100);
			switch_Motor(off);


			while (PB.DR.BIT.B5 != 0)
				;
			UX_effect(alart);
			switch_Motor(on);
			wait_ms(100);
			mot_app(spec.r_distance, 310, 2000, right, on);
			wait_ms(100);
			switch_Motor(off);

			while (PB.DR.BIT.B5 != 0)
				;
			UX_effect(alart);
			switch_Motor(on);
			wait_ms(100);
			mot_app(spec.l_distance, 310, 2000, left, on);
			wait_ms(100);
			switch_Motor(off);

			while (PB.DR.BIT.B5 != 0)
				;
			UX_effect(alart);
			switch_Motor(on);
			wait_ms(100);
			mot_app2(spec.half_block, 330, 2000, straight, on);
			mot_app2(spec.full_block * 5, 480, 2000, straight, on);
			mot_app(spec.half_block, 330, 2000, straight, on);
			wait_ms(100);
			switch_Motor(off);

			spec.sta_LED_flag = 0;

			break;
		}

		switch_Motor(off);

	}

}

