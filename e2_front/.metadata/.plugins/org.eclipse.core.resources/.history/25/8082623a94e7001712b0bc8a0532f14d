/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  test                                   */
/*      FILE         :  test.c                                 */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  SH-2                                   */
/*      CPU TYPE     :  SH7125                                 */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/

#include "typedefine.h"
#include "iodefine.h"
#include "serial.h"
#include "init.h"
#include "math.h"

#define round(A)((int)(A + 0.5))

char status, dist_flag_l = 0, dist_flag_r = 0, end_l = 0, end_r = 0, clt = 0,
		stop_l = 0, stop_r = 0, cnt_ctl = 0;
int count_cmt_0 = 0, count_cmt_1, i, rot = -1, old = 0, cnt_l = 0, cnt_r = 0,
		distance, duty_R = 0, duty_R_h = 0, duty_L = 0, duty_L_h = 0;
//dist_flag_l = 0, dist_flag_r = 0, end_l = 0, end_r = 0, distance;
double vel_l = 250, vel_r = 250, tar_vel_l = 300, tar_vel_r = 300, acc_l = 200,
		acc_r = 200;
float batt, diff, kp_r = 1000, kp_l = 1000;
short sen_diff_l = 0, sen_diff_r = 0, sen_old_L, sen_old_R;
short duty[17];
short sen[4];

extern SPEC spec;

enum AD_C {
	ad_0 = 0, ad_1 = 1
};
enum sensor {
	CR = 0, R, CL, L //センサの順番通り
};

enum status_LED {
	Red = 0, Yerrow = 1, Green = 2, Rst_status_LED = 3, ALL_status_LED
};

enum sensor_LED {
	Rst_sensor_LED = 0,
	CR_LED = 1,
	R_LED = 2,
	L_LED = 3,
	CL_LED = 4,
	ALL_sensor_LED
};
/*
 enum sen_mode {
 pulse = 0, meter = 1
 };
 */
enum cst {
	cst0 = 0, cst1, cst2, cst3, cst_all
};

enum turn {
	right = 0, left, straight, back
};

enum motor {
	R_motor = 0, L_motor
};

void pass(void) {
	//pass
}

int get_sensor(int ch, int ad_c) {

	switch (ad_c) {
	case ad_0:
		AD0.ADCR.BIT.ADST = 0;		//AD停止
		AD0.ADCSR.BIT.CH = ch;		//チャンネル選択
		AD0.ADCR.BIT.ADST = 1;		//AD再開
		while (AD0.ADCSR.BIT.ADF == 0)
			;
		AD0.ADCSR.BIT.ADF = 0;
		if (ch == 0) {
			return AD0.ADDR0 >> 6;
		} else if (ch == 1) {
			return AD0.ADDR1 >> 6;
		} else if (ch == 2) {
			return AD0.ADDR2 >> 6;
		} else if (ch == 3) {
			return AD0.ADDR3 >> 6;
		} else {
			return -1;
		}
		break;
	case ad_1:
		AD1.ADCR.BIT.ADST = 0;		//AD停止
		AD1.ADCSR.BIT.CH = ch;		//チャンネル選択
		AD1.ADCR.BIT.ADST = 1;		//AD再開
		while (AD1.ADCSR.BIT.ADF == 0)
			;
		AD1.ADCSR.BIT.ADF = 0;
		if (ch == 0) {
			return AD1.ADDR4 >> 6;
		} else if (ch == 1) {
			return AD1.ADDR5 >> 6;
		} else if (ch == 2) {
			return AD1.ADDR6 >> 6;
		} else if (ch == 3) {
			return AD1.ADDR7 >> 6;
		} else {
			return -1;
		}
		break;
	}

}

void sen_LED(int ch) {
	/*
	 PE9 : sensor_right
	 PE11 : sensor_center_right
	 PE13 : sensor_center_left
	 PE12 : sensor_left
	 */
	switch (ch) {
	case R_LED:
		PE.DRL.BIT.B9 = 1;
		break;
	case CR_LED:
		PE.DRL.BIT.B11 = 1;
		break;
	case CL_LED:
		PE.DRL.BIT.B13 = 1;
		break;
	case L_LED:
		PE.DRL.BIT.B12 = 1;
		break;
	case Rst_sensor_LED:
		PE.DRL.BIT.B9 = 0;
		PE.DRL.BIT.B11 = 0;
		PE.DRL.BIT.B12 = 0;
		PE.DRL.BIT.B13 = 0;
		break;
	case ALL_sensor_LED:
		PE.DRL.BIT.B9 = 1;
		PE.DRL.BIT.B11 = 1;
		PE.DRL.BIT.B12 = 1;
		PE.DRL.BIT.B13 = 1;
		break;
	}
}

void diff_con(char flag) {
	short ref_boost_L, ref_boost_R;
	sen_diff_r = sen[1] - sen_old_R;
	sen_diff_l = sen[3] - sen_old_L;
	if (abs(sen_diff_r) > spec.sen_diff_threshold) {
		ref_boost_R = 10;  //変化量が一定以上なら、閾値を引き上げる
	} else {
		ref_boost_R = 0; //変化量が一定以下なら、設定通りの閾値
	}

	if (abs(sen_diff_l) > spec.sen_diff_threshold) {
		ref_boost_L = 10;  //変化量が一定以上なら、閾値を引き上げる
	} else {
		ref_boost_L = 0; //変化量が一定以下なら、設定通りの閾値
	}

	if (flag == 1) {
		diff = (float) (cnt_l - cnt_r) * 0.1;
	} else if ((sen[1] >= spec.sen_ref_wall_R)
			&& (sen[3] >= spec.sen_ref_wall_L)) {
		diff = (float) ((sen[3] - (spec.sen_ref_L + ref_boost_L))
				- (sen[1] - (spec.sen_ref_R + ref_boost_R)));
	} else if ((sen[1] >= spec.sen_ref_wall_R)
			&& (sen[3] < spec.sen_ref_wall_L)) {
		diff = (float) (-2 * (sen[1] - (spec.sen_ref_R + ref_boost_R)));
	} else if ((sen[1] < spec.sen_ref_wall_R)
			&& (sen[3] >= spec.sen_ref_wall_L)) {
		diff = (float) (2 * (sen[3] - (spec.sen_ref_L + ref_boost_L)));
	} else {
		diff = (float) (cnt_l - cnt_r) * 0.05;
	}
	PE.DRL.BIT.B10 = 0;

}

void interrupt_cmt0() {
// write this function to interrupt_handlers.c
	CMT0.CMCSR.BIT.CMF = 0;
	++count_cmt_0;
}
void interrupt_cmt1() {
// write this function to interrupt_handlers.c
	CMT1.CMCSR.BIT.CMF = 0;
	++count_cmt_1;
}

void wait_h_ms(int t) {
	count_cmt_1 = 0;
	CMT1.CMCNT = 0;
	while (count_cmt_1 < t)
		;
}

void wait_ms(int t) {
	count_cmt_0 = 0;
	CMT0.CMCNT = 0;
	while (count_cmt_0 < t)
		;
}

void sen_cmt1(SPEC s) {
// write this function to interrupt_handlers.c
	CMT1.CMCSR.BIT.CMF = 0;
	CMT1.CMCNT = 0;

	sen_old_R = sen[1];
	sen_old_L = sen[3];
	sen_LED(ALL_sensor_LED);
	sen[0] = (short) (((float) get_sensor(CR, ad_0) - s.sen_min_CR)
			/ (s.sen_max_CR - s.sen_min_CR) * 100);		//CR sensor
	sen[1] = (short) (((float) get_sensor(R, ad_0) - s.sen_min_R)
			/ (s.sen_max_R - s.sen_min_R) * 100);		//R sensor
	sen[2] = (short) (((float) get_sensor(CL, ad_0) - s.sen_min_CL)
			/ (s.sen_max_CL - s.sen_min_CL) * 100);		//CL sensor
	sen[3] = (short) (((float) get_sensor(L, ad_0) - s.sen_min_L)
			/ (s.sen_max_L - s.sen_min_L) * 100);		//L sensor
	sen_LED(Rst_sensor_LED);
	/*
	sen[0] = get_sensor(CR, ad_0)
	sen[1] = get_sensor(R, ad_0)
	sen[2] = get_sensor(CL, ad_0)
	sen[3] = get_sensor(L, ad_0)
	*/

	if (clt == 1) {
		diff_con(cnt_ctl);
	}

	if (tar_vel_l + kp_l * diff > vel_l) {
		vel_l = vel_l + (acc_l * 0.001);
	} else if (tar_vel_l + kp_l * diff < vel_l) {
		if (tar_vel_l + kp_l * diff >= spec.vel_min) {
			vel_l = vel_l - (acc_l * 0.001);
		} else {
			vel_l = spec.vel_min;
		}
	} else {
		//pass
	}

	if (tar_vel_r - kp_r * diff > vel_r) {
		vel_r = vel_r + (acc_r * 0.001);
	} else if (tar_vel_r - kp_r * diff < vel_r) {
		if (tar_vel_r - kp_r * diff >= spec.vel_min) {
			vel_r = vel_r - (acc_r * 0.001);
		} else {
			vel_r = spec.vel_min;
		}
	} else {
		//pass
	}

}

void stopMTU(int cst) {
//stop MTU2's timer
	switch (cst) {
	case cst0:
		MTU2.TSTR.BIT.CST0 = 0;
		break;
	case cst1:
		MTU2.TSTR.BIT.CST1 = 0;
		break;
	case cst2:
		MTU2.TSTR.BIT.CST2 = 0;
		break;
	case cst3:
		MTU2.TSTR.BIT.CST3 = 0;
		MTU2.TSTR.BIT.CST4 = 0;
		break;
	case cst_all:
		MTU2.TSTR.BIT.CST0 = 0;
		MTU2.TSTR.BIT.CST1 = 0;
		MTU2.TSTR.BIT.CST2 = 0;
		MTU2.TSTR.BIT.CST3 = 0;
		MTU2.TSTR.BIT.CST4 = 0;
		break;
	}
}

void startMTU(int cst) {
//start MTU2's timer
	switch (cst) {
	case cst0:
		MTU2.TSTR.BIT.CST0 = 1;
		break;
	case cst1:
		MTU2.TSTR.BIT.CST1 = 1;
		break;
	case cst2:
		MTU2.TSTR.BIT.CST2 = 1;
		break;
	case cst3:
		MTU2.TSTR.BIT.CST3 = 1;
		MTU2.TSTR.BIT.CST4 = 1;
		break;
	case cst_all:
		MTU2.TSTR.BIT.CST0 = 1;
		MTU2.TSTR.BIT.CST1 = 1;
		MTU2.TSTR.BIT.CST2 = 1;
		MTU2.TSTR.BIT.CST3 = 1;
		MTU2.TSTR.BIT.CST4 = 1;
		break;
	}
}

void MTU20_INT_OVF(void) {
	/*
	 * this function operates R_motor
	 * */

	stopMTU(cst0); //stop count
	/*
	 if (tar_vel_r + kp_r * diff > vel_r) {
	 vel_r = sqrt((vel_r * vel_r) + (2 * acc_r * 0.408407)); //(sqrt(vel_l^2 + 2*a*step_distance))
	 } else if (tar_vel_r + kp_r * diff < vel_r) {
	 vel_r = sqrt((vel_r * vel_r) - (2 * acc_r * 0.408407)); //(sqrt(vel_l^2 + 2*a*step_distance))
	 } else {
	 //pass
	 }
	 */
	duty_R = (1 / vel_r) * (2.55e+6); //(1/v)*(step_distance / MTU_clock_duty)
	duty_R_h = round(duty_R / 2);

	cnt_r--;

//change duty
	if (MTU20.TSR.BIT.TGFA == 1) {

		MTU20.TCNT = 0; //reset counter

		if (duty_R <= 0) {
			MTU20.TGRA = 0;
		} else {
			MTU20.TGRA = duty_R; //(1/v)*(step_distance / MTU_clock_duty)
		}
		if (duty_R_h <= 0) {
			MTU20.TGRB = 0;
		} else {
			MTU20.TGRB = duty_R_h; //(1/v)*(step_distance / MTU_clock_duty)
		}
	}

	MTU20.TSR.BIT.TGFA = 0; //reset flag

	if (cnt_r < 0 && end_r == 1) {
		dist_flag_r = 1;
		stopMTU(cst0);
	} else if (stop_r == 1) {
		stopMTU(cst0);
	} else {
		startMTU(cst0);
	}

}

void MTU21_INT_OVF(void) {
	stopMTU(cst1); //stop count
	/*
	 * this function operates L_motor
	 * */
	/*
	 if (tar_vel_l - kp_l * diff > vel_l) {
	 vel_l = sqrt((vel_l * vel_l) + (2 * acc_l * 0.408407)); //(sqrt(vel_l^2 + 2*a*step_distance))
	 } else if (tar_vel_l - kp_l * diff < vel_l) {
	 vel_l = sqrt((vel_l * vel_l) - (2 * acc_l * 0.408407)); //(sqrt(vel_l^2 + 2*a*step_distance))
	 } else {
	 //pass
	 }
	 */
	duty_L = (1 / vel_l) * (2.55e+6); //(1/v)*(step_distance / MTU_clock_duty)
	duty_L_h = round(duty_L / 2);

	cnt_l--;

	if (MTU21.TSR.BIT.TGFA == 1) {
		//change duty
		MTU21.TCNT = 0; //reset counter

		if (duty_L <= 0) {
			MTU21.TGRA = 0;
		} else {
			MTU21.TGRA = duty_L;
		}
		if (duty_L_h <= 0) {
			MTU21.TGRB = 0;
		} else {
			MTU21.TGRB = duty_L_h;
		}
	}
	MTU21.TSR.BIT.TGFA = 0; //reset flag

	if (cnt_l < 0 && end_l == 1) {
		dist_flag_l = 1;
		stopMTU(cst1);
	} else if (stop_l == 1) {
		stopMTU(cst1);
	} else {
		startMTU(cst1);
	}
}
/*
 void MTU22_INT_OVF(void) {
 stopMTU(cst2); //stop count
 if (MTU22.TSR.BIT.TGFA == 1) {
 //change duty
 MTU22.TCNT = 0; //reset counter

 if (duty[6] <= 0) {
 MTU22.TGRA = 0;
 } else {
 MTU22.TGRA = duty[6];
 }
 if (duty[7] <= 0) {
 MTU22.TGRB = 0;
 } else {
 MTU22.TGRB = duty[7];
 }
 }
 MTU22.TSR.BIT.TGFA = 0; //reset flag
 startMTU(cst2);
 }

 void MTU23A_INT_OVF(void) {
 stopMTU(cst3); //stop count
 if (MTU23.TSR.BIT.TGFA == 1) {
 //change duty
 MTU23.TCNT = duty[16]; //reset counter
 if (duty[8] <= 0) {
 MTU23.TGRA = 0;
 } else {
 MTU23.TGRA = duty[8];
 }
 if (duty[9] <= 0) {
 MTU23.TGRB = 0;
 } else {
 MTU23.TGRB = duty[9];
 }
 if (duty[12] <= 0) {
 MTU24.TGRA = 0;
 } else {
 MTU24.TGRA = duty[12];
 }
 if (duty[13] <= 0) {
 MTU24.TGRB = 0;
 } else {
 MTU24.TGRB = duty[13];
 }
 }
 MTU23.TSR.BIT.TGFA = 0; //reset flag
 startMTU(cst3);
 }


 void MTU23C_INT_OVF(void) {
 stopMTU(); //stop count
 if (MTU23.TSR.BIT.TGFC == 1) {
 if (duty[10] <= 0) {
 MTU23.TGRC = 0;
 } else {
 MTU23.TGRC = duty[10];
 }
 if (duty[11] <= 0) {
 MTU23.TGRD = 0;
 } else {
 MTU23.TGRD = duty[11];
 }
 }
 MTU23.TSR.BIT.TGFC = 0; //reset flag
 startMTU();
 }
 */

void sta_LED(int color) {
	switch (color) {
	case Red:
		PE.DRL.BIT.B8 = 1;
		break;
	case Yerrow:
		PE.DRL.BIT.B6 = 1;
		break;
	case Green:
		PE.DRL.BIT.B10 = 1;
		break;
	case Rst_status_LED:
		PE.DRL.BIT.B8 = 0;
		PE.DRL.BIT.B6 = 0;
		PE.DRL.BIT.B10 = 0;
		break;
	}
}

void Buzzer(int ms) {
	if (ms < 50) {
		return;
	} else {
		int i, times = round(ms / 50);
		for (i = 0; i < times; i++) {
			PE.DRL.BIT.B7 = 1;
			wait_ms(40);
			PE.DRL.BIT.B7 = 0;
			wait_ms(10);
		}
	}
}

int Rotate_detect(void) {
	int now = PE.DRL.BIT.B14;
	now = now << 1;
	now += PE.DRL.BIT.B15;

	if (now == 3) {
		now = 2;
	} else if (now == 2) {
		now = 3;
	}

	if (old == 0 && now == 3) {
		rot -= 1;
		Buzzer(100);
	} else if (old == 3 && now == 0) {
		rot += 1;
		Buzzer(100);
	} else if (now > old) {
		rot += 1;
		Buzzer(100);
	} else if (now < old) {
		rot -= 1;
		Buzzer(100);
	} else {
		rot += 0;
	}
	old = now;
	return rot;
}

float batt_vol(void) {
	float vol_ad, voltage;
	vol_ad = (float) get_sensor(3, ad_1) / 1024.0 * 5.0;
	voltage = vol_ad * ((100.0 + 51.0) / 51.0);
	return voltage;
}
/*
 void mot_drv_2(int dist, int vel, int acc, int turn, int end) {
 dist_flag_l = 0;
 dist_flag_r = 0;
 PE.DRL.BIT.B2 = 1; //reset(0 : off, 1 : on)
 if (end == 1) {
 end_l = 1;
 end_r = 1;
 }
 switch (turn) {
 case right:
 PE.DRL.BIT.B1 = 1; //R_CW/CCW(0 : forward, 1 : backward)
 PE.DRL.BIT.B5 = 1; //L_CW/CCW(1 : forward, 0 : backward)
 break;
 case left:
 PE.DRL.BIT.B1 = 0; //R_CW/CCW(0 : forward, 1 : backward)
 PE.DRL.BIT.B5 = 0; //L_CW/CCW(1 : forward, 0 : backward)
 break;
 case straight:
 PE.DRL.BIT.B1 = 0; //R_CW/CCW(0 : forward, 1 : backward)
 PE.DRL.BIT.B5 = 1; //L_CW/CCW(1 : forward, 0 : backward)
 break;
 case back:
 PE.DRL.BIT.B1 = 1; //R_CW/CCW(0 : forward, 1 : backward)
 PE.DRL.BIT.B5 = 0; //L_CW/CCW(1 : forward, 0 : backward)
 break;
 }
 if (vel < 300) {
 stopMTU(cst0);
 stopMTU(cst1);
 vel = 300;
 } else {
 startMTU(cst0);
 startMTU(cst1);
 }
 cnt_l = (int) (dist / 0.408407); //(distance / step_distance )
 cnt_r = cnt_l;
 acc_l = acc;
 acc_r = acc_l;
 tar_vel_l = vel;
 tar_vel_r = vel;
 PE.DRL.BIT.B2 = 0; //reset(0 : off, 1 : on)
 }
 */
void mot_drv(int dist, int vel, int acc, int rot_dir, int end, int ch) {
	/*
	 rot_dir
	 1 : forward
	 0 : backward
	 */

	PE.DRL.BIT.B2 = 1; //reset(0 : off, 1 : on)

	switch (rot_dir) {
	case 1:
		switch (ch) {
		case R_motor:
			PE.DRL.BIT.B1 = 0; //R_CW/CCW(0 : forward, 1 : backward)
			stop_r = 0;
			break;
		case L_motor:
			PE.DRL.BIT.B5 = 1; //L_CW/CCW(1 : forward, 0 : backward)
			stop_l = 0;
			break;
		}
		break;
	case 0:
		switch (ch) {
		case R_motor:
			PE.DRL.BIT.B1 = 1; //R_CW/CCW(0 : forward, 1 : backward)
			stop_r = 0;
			break;
		case L_motor:
			PE.DRL.BIT.B5 = 0; //L_CW/CCW(1 : forward, 0 : backward)
			stop_l = 0;
			break;
		}
		break;
	}

	if (vel < 300) {
		/*
		 switch (ch) {
		 case R_motor:
		 stop_r = 1;
		 break;
		 case L_motor:
		 stop_l = 1;
		 break;
		 }*/
		vel = 300;
	}

	switch (ch) {
	case R_motor:
		cnt_r = (int) (dist / 0.408407); //(distance / step_distance )
		acc_r = acc;
		tar_vel_r = vel;
		dist_flag_r = 0;
		end_r = 0;
		startMTU(cst0);
		break;

	case L_motor:
		cnt_l = (int) (dist / 0.408407); //(distance / step_distance )
		acc_l = acc;
		tar_vel_l = vel;
		dist_flag_l = 0;
		end_l = 0;
		startMTU(cst1);
		break;
	}
	if (end == 1 && ch == L_motor) {
		end_l = 1;
	} else if (end == 1 && ch == R_motor) {
		end_r = 1;
	}

	PE.DRL.BIT.B2 = 0; //reset(0 : off, 1 : on)

}

void mot_app(int dist, int vel, int acc, int turn, int ed, char coll) {
	switch (turn) {
	case straight:
		mot_drv(dist, vel, acc, 1, ed, R_motor);
		mot_drv(dist, vel, acc, 1, ed, L_motor);
		break;

	case right:
		mot_drv(dist, vel, acc, 1, ed, R_motor);
		mot_drv(dist, vel, acc, 0, ed, L_motor);
		break;

	case left:
		mot_drv(dist, vel, acc, 0, ed, R_motor);
		mot_drv(dist, vel, acc, 1, ed, L_motor);
		break;

	case back:
		mot_drv(dist, vel, acc, 0, ed, R_motor);
		mot_drv(dist, vel, acc, 0, ed, L_motor);
		break;
	}
	clt = coll;

}

int main(void) {
	float v_r = 0;
	float v_l = 0;
	init_sci1();
	initALL();

//	PE.DRL.BIT.B6 = 0;
	PE.DRL.BIT.B7 = 0;

	duty[0] = 6250 - 1;		//(1ms)
	duty[1] = round(duty[0] / 2);		//(about 0.5ms)
	duty[4] = 6250 - 1;		//(1ms)
	duty[5] = round(duty[4] / 2);		//(about 0.5ms)
//duty[0] = 0;		//(1ms)
//duty[1] = 0;		//(about 0.5ms)
//duty[4] = 0;		//(1ms)
//duty[5] = 0;		//(about 0.5ms)
//	duty[6] = 6250 - 1;		//(1ms)
//	duty[7] = round(duty[6] / 2);		//(about 0.5ms)
//	duty[8] = 6250 - 1;		//(1ms)
//	duty[9] = round(duty[8] / 2);		//(about 0.5ms)
//	duty[12] = round(duty[8] / 2);		//(about 0.5ms)
//	duty[13] = round(duty[8] / 2);		//(about 0.5ms)
//	duty[16] = 0; //for reset MTU count

	while (batt_vol() < 11.3) {
		myprintf("Low_battery\n");
		sta_LED(Red);
		Buzzer(200);
		sta_LED(Rst_status_LED);
	}

	sta_LED(Rst_status_LED);
//startMTU(cst2);
//startMTU(cst3);
	myprintf("start \n");
//clt = 1;
	while (1) {
		batt = batt_vol();
		//myprintf("\n%f | %d \n", batt, rot);
		myprintf("%f\n", batt);
		myprintf("\n");
		wait_ms(100);

		if (PB.DR.BIT.B5 != 0) {
			//sen_LED(Rotate_detect() % 5, pulse);
			for (i = 0; i < 4; i++) {
				myprintf("%d |", sen[i]);
			}
		} else {
			sta_LED(Green);
			Buzzer(200);
			wait_ms(3000);
			sta_LED(Rst_status_LED);
			distance = (int) ((90.0 / 180 * 3.1415) * (spec.tire_dim / 2));
			while (1) {

				wait_ms(100);
				cnt_ctl = 1;
				mot_app(93, 300, 500, straight, 1, 1);
				cnt_ctl = 0;
				while (dist_flag_l != 1)
					;
				if (sen[1] <= spec.sen_ref_non_L) {
					mot_app(94, 500, 500, straight, 1, 1);
					while (dist_flag_l != 1)
						;
					cnt_ctl = 1;
					wait_ms(1000);
					mot_app(distance, 300, 500, left, 1, 1);
					while (dist_flag_l != 1)
						;
					cnt_ctl = 0;
					wait_ms(1000);

				} else if (sen[2] <= spec.sen_ref_non_CL) {
					mot_app(94, 500, 500, straight, 1, 1);
					while (dist_flag_r != 1)
						;

				} else if (sen[3] <= spec.sen_ref_non_R) {
					mot_app(94, 300, 500, straight, 1, 1);
					while (dist_flag_l != 1)
						;
					cnt_ctl = 1;
					wait_ms(1000);
					mot_app(distance, 300, 500, right, 1, 1);
					while (dist_flag_l != 1)
						;
					cnt_ctl = 0;
					wait_ms(1000);

				} else {
					mot_app(94, 500, 500, straight, 1, 1);
					while (dist_flag_l != 1)
						;
					cnt_ctl = 1;
					wait_ms(500);
					mot_app(distance, 300, 500, left, 1, 1);
					while (dist_flag_l != 1)
						;
					wait_ms(500);
					mot_app(100, 300, 500, back, 1, 1);
					while (dist_flag_l != 1)
						;
					wait_ms(500);
					mot_app(15, 300, 500, straight, 1, 1);
					while (dist_flag_l != 1)
						;
					wait_ms(1500);
					mot_app(distance, 300, 500, left, 1, 1);
					while (dist_flag_l != 1)
						;
					wait_ms(500);
					mot_app(100, 300, 500, back, 1, 1);
					while (dist_flag_l != 1)
						;
					wait_ms(500);
					mot_app(15, 300, 500, straight, 1, 1);
					while (dist_flag_l != 1)
						;
					wait_ms(500);
					cnt_ctl = 0;
				}
			}
			/*
			 for (i = 0; i < 2; i++) {

			 mot_app(45, 400, 500, straight, 1, 0);
			 while (dist_flag_l != 1)
			 ;
			 mot_app(900, 700, 800, straight, 1, 1);
			 while (dist_flag_l != 1) {
			 if ((sen[1] >= spec.sen_ref_wall_R)
			 && (sen[3] < spec.sen_ref_wall_L)) {
			 sta_LED(Yerrow);
			 } else if ((sen[1] < spec.sen_ref_wall_R)
			 && (sen[3] >= spec.sen_ref_wall_L)) {
			 sta_LED(Green);
			 }
			 }
			 mot_app(45, 300, 500, straight, 1, 0);
			 while (dist_flag_l != 1)
			 ;
			 wait_ms(500);
			 cnt_ctl = 1;
			 mot_app(2 * distance, 300, 20, right, 1, 1);
			 while (dist_flag_l != 1)
			 ;
			 cnt_ctl = 0;
			 wait_ms(500);
			 }
			 sta_LED(Rst_status_LED);
			 */
		}

	}

}

